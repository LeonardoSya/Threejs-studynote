<!--
 * @Author: LeonardoSya 2246866774@qq.com
 * @Date: 2023-10-10 20:07:10
 * @LastEditors: LeonardoSya 2246866774@qq.com
 * @LastEditTime: 2023-10-13 10:41:44
 * @FilePath: \three.js\02_cube与响应式设计.html
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        #c {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>

</head>


<body>
    <canvas id="c"></canvas>
</body>

<script type="module">
    import * as THREE from '/node_modules/three/build/three.module.js';

    function main() {
        const canvas = document.querySelector('#c')
        const renderer = new THREE.WebGLRenderer({ antialias: true, canvas })

        const fov = 75;
        const aspect = window.innerWidth / window.innerHeight;
        const near = 1;
        const far = 15;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far)

        camera.position.z = 5;

        const scene = new THREE.Scene();

        const boxWidth = 1;
        const boxHeight = 1;
        const boxDepth = 1;
        const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);


        // 纹理   
        // 创建一个TextureLoader，调用它的load方法，将材质的map属性设置为该方法的返回值 而不是color
        const loader = new THREE.TextureLoader();
        const texture = loader.load('src/pic/wall.jpg');
        texture.colorSpace = THREE.SRGBColorSpace;
        const material = new THREE.MeshBasicMaterial({
            // color: ...
            map: texture,
        })

        // {
        //     const color = 0xffffff;
        //     const intensity = 5;
        //     const light = new THREE.DirectionalLight(color, intensity);
        //     light.position.set(-1, 2, 4);
        //     scene.add(light);
        // }

        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);   // 每当创建了一个表示物体的虚拟对象Mesh，都需要通过.add()方法，把网格模型mesh添加到三维场景scene中


        renderer.render(scene, camera);

        function resizeRendererToDisplaySize(renderer) {
            const canvas = renderer.domElement;
            const pixelRatio = window.devicePixelRatio;
            const width = canvas.clientWidth * pixelRatio | 0;
            const height = canvas.clientHeight * pixelRatio | 0;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
                renderer.setSize(width, height, false)
            }
            return needResize;
        }


        function render(time) {

            if (resizeRendererToDisplaySize(renderer)) {
                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
            }

            time *= 0.001;

            cube.rotation.x = time / 7;
            cube.rotation.y = time / 7;

            renderer.render(scene, camera);
            requestAnimationFrame(render);
            requestAnimationFrame(render);



        }

    }
    main();

</script>

</html>